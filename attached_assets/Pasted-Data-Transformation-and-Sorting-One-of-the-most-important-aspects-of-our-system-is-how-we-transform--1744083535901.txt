Data Transformation and Sorting
One of the most important aspects of our system is how we transform the raw API data into structured formats for different views:
Leaderboard Transformation
When the API data comes in, we transform it using a specialized function:
function transformLeaderboardData(apiData: any) {
// Extract data from various possible API response formats
const responseData = apiData.data || apiData.results || apiData;

// Transform each entry to our standard format
const transformedData = dataArray.map((entry) => ({
uid: entry.uid || "",
name: entry.name || "",
wagered: {
today: entry.wagered?.today || 0,
this_week: entry.wagered?.this_week || 0,
this_month: entry.wagered?.this_month || 0,
all_time: entry.wagered?.all_time || 0,
},
}));

// Return the data structured by time periods
return {
status: "success",
metadata: {
totalUsers: transformedData.length,
lastUpdated: new Date().toISOString(),
},
data: {
today: { data: sortByWagered(transformedData, "today") },
weekly: { data: sortByWagered(transformedData, "this_week") },
monthly: { data: sortByWagered(transformedData, "this_month") },
all_time: { data: sortByWagered(transformedData, "all_time") },
},
};
}

Sorting Function
The sorting for leaderboards is handled by this key function:
function sortByWagered(data: any[], period: string) {
return [...data].sort(
(a, b) => (b.wagered[period] || 0) - (a.wagered[period] || 0)
);
}

This creates sorted arrays for each time period (daily, weekly, monthly, all-time) which is critical for leaderboard displays.
4. Wager Race Data Processing
For the wager races, we transform the leaderboard data into race-specific formats:
const raceData = {
id: `${now.getFullYear()}${(now.getMonth() + 1).toString().padStart(2, '0')}`,
status: 'live',
startDate: new Date(2025, 1, 1).toISOString(),
endDate: endOfMonth.toISOString(),
prizePool: 500,
participants: stats.data.monthly.data.map((participant: any, index: number) => ({
uid: participant.uid,
name: participant.name,
wagered: participant.wagered.this_month,
position: index + 1
})).slice(0, 10),
totalWagered: stats.data.monthly.data.reduce((sum: number, p: any) => sum + p.wagered.this_month, 0),
participantCount: stats.data.monthly.data.length,
metadata: {
transitionEnds: new Date(2025, 2, 1).toISOString(),
nextRaceStarts: new Date(2025, 2, 1).toISOString(),
prizeDistribution: [0.5, 0.3, 0.1, 0.05, 0.05]
}
};
