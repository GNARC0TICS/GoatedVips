Handling Polling for Your Telegram Bot in a Shared Deployment

Since your Telegram bot shares the same deployment as your website, you need to make sure polling works efficiently without blocking the Express server or causing multiple instances to run.

1️⃣ Understanding Polling in a Shared Deployment

There are two ways to receive messages from Telegram:
	•	Polling (Long Polling)
	•	The bot continuously requests new updates from Telegram.
	•	Suitable for development or small deployments.
	•	Webhooks
	•	Telegram sends updates directly to your server.
	•	Recommended for production with a stable domain.

Since you’re running both the website and bot on the same deployment, polling is the easiest method unless you have a public domain for webhooks.

2️⃣ Setting Up Polling in bot.ts

Modify your server/bot.ts file:

import TelegramBot from "node-telegram-bot-api";
import dotenv from "dotenv";

dotenv.config();

if (!process.env.TELEGRAM_BOT_TOKEN) {
  throw new Error("❌ TELEGRAM_BOT_TOKEN is required!");
}

// Create bot instance with **polling mode**
export const bot = new TelegramBot(process.env.TELEGRAM_BOT_TOKEN, {
  polling: {
    interval: 500,  // Lower interval for faster response
    autoStart: true,
    params: {
      timeout: 10,   // Ensures it reconnects quickly if disconnected
    },
  },
});

console.log("🤖 Telegram bot is running in polling mode...");

// Handle errors gracefully
bot.on("polling_error", (error) => {
  console.error("⚠️ Polling Error:", error.message);
});

bot.on("message", (msg) => {
  console.log(`📩 Received message from @${msg.from?.username}: ${msg.text}`);
});

// Graceful shutdown for polling
process.on("SIGINT", async () => {
  console.log("🛑 Stopping bot polling...");
  await bot.stopPolling();
  console.log("✅ Bot polling stopped.");
});

✅ Key Features
	•	Polling is enabled with a 500ms interval for responsiveness.
	•	Auto-reconnects if polling stops.
	•	Graceful shutdown ensures clean exit when deployment restarts.

3️⃣ Preventing Multiple Bot Instances

Since Replit Deployments auto-restart, it’s critical to prevent duplicate polling instances.
Use Process Management (PM2) or a Singleton Lock.

🔹 Method 1: Using PM2 (Recommended)

If running in PM2, make sure your pm2.config.js prevents multiple bots:

module.exports = {
  apps: [
    {
      name: "website",
      script: "./server/index.ts",
      interpreter: "tsx",
      watch: true,
    },
    {
      name: "telegram-bot",
      script: "./server/bot.ts",
      interpreter: "tsx",
      watch: true,
      autorestart: true,  // Auto-restart bot if it crashes
      instances: 1,       // Prevent multiple polling instances
    }
  ]
};

Then run:

pm2 start pm2.config.js
pm2 save

✅ This ensures only ONE polling bot instance runs!

🔹 Method 2: Check for Existing Bot Instances

Modify bot.ts to check for running instances before polling:

import fs from "fs";
const BOT_LOCK_FILE = "/tmp/telegram_bot.lock";

if (fs.existsSync(BOT_LOCK_FILE)) {
  console.log("⚠️ Telegram bot is already running. Skipping duplicate instance.");
  process.exit(1);
}

fs.writeFileSync(BOT_LOCK_FILE, process.pid.toString());

✅ Prevents multiple bots from running accidentally.

4️⃣ Switching to Webhooks for Production (Optional)

If you have a public domain (e.g., https://my-bot.com), use webhooks instead of polling.

Modify bot.ts:

const webhookUrl = `${process.env.PUBLIC_URL}/webhook/${process.env.TELEGRAM_BOT_TOKEN}`;

bot.setWebHook(webhookUrl).then(() => {
  console.log(`✅ Webhook set: ${webhookUrl}`);
});

Then, modify index.ts to handle Telegram updates:

app.post(`/webhook/${process.env.TELEGRAM_BOT_TOKEN}`, (req, res) => {
  bot.processUpdate(req.body);
  res.sendStatus(200);
});

🚀 Now Telegram sends updates directly to your server instead of polling!

5️⃣ Final Deployment Checklist

✅ Does polling start correctly in Replit logs?
✅ Does /start respond in Telegram?
✅ Is polling running only once (pm2 list)?
✅ Are logs clear of polling errors?

🎯 You’re Now Running a Polling Bot in the Same Deployment!

This setup ensures your bot and website run smoothly together, without duplicate polling instances. 🚀