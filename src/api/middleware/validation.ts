import { Request, Response, NextFunction } from 'express';\nimport { z } from 'zod';\n\n// Generic validation middleware for request body\nexport function validateRequest<T extends z.ZodSchema>(\n  schema: T\n) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const result = schema.safeParse(req.body);\n      \n      if (!result.success) {\n        return res.status(400).json({\n          success: false,\n          error: 'Validation failed',\n          code: 'VALIDATION_ERROR',\n          details: result.error.issues.map(issue => ({\n            field: issue.path.join('.'),\n            message: issue.message,\n            code: issue.code,\n          })),\n        });\n      }\n      \n      // Replace req.body with validated data\n      req.body = result.data;\n      next();\n    } catch (error) {\n      console.error('Validation middleware error:', error);\n      res.status(500).json({\n        success: false,\n        error: 'Validation error',\n        code: 'VALIDATION_SYSTEM_ERROR',\n      });\n    }\n  };\n}\n\n// Validation middleware for query parameters\nexport function validateQuery<T extends z.ZodSchema>(\n  schema: T\n) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const result = schema.safeParse(req.query);\n      \n      if (!result.success) {\n        return res.status(400).json({\n          success: false,\n          error: 'Query validation failed',\n          code: 'QUERY_VALIDATION_ERROR',\n          details: result.error.issues.map(issue => ({\n            field: issue.path.join('.'),\n            message: issue.message,\n            code: issue.code,\n          })),\n        });\n      }\n      \n      // Replace req.query with validated data\n      req.query = result.data as any;\n      next();\n    } catch (error) {\n      console.error('Query validation middleware error:', error);\n      res.status(500).json({\n        success: false,\n        error: 'Query validation error',\n        code: 'QUERY_VALIDATION_SYSTEM_ERROR',\n      });\n    }\n  };\n}\n\n// Validation middleware for URL parameters\nexport function validateParams<T extends z.ZodSchema>(\n  schema: T\n) {\n  return (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const result = schema.safeParse(req.params);\n      \n      if (!result.success) {\n        return res.status(400).json({\n          success: false,\n          error: 'Parameter validation failed',\n          code: 'PARAMS_VALIDATION_ERROR',\n          details: result.error.issues.map(issue => ({\n            field: issue.path.join('.'),\n            message: issue.message,\n            code: issue.code,\n          })),\n        });\n      }\n      \n      // Replace req.params with validated data\n      req.params = result.data;\n      next();\n    } catch (error) {\n      console.error('Params validation middleware error:', error);\n      res.status(500).json({\n        success: false,\n        error: 'Parameter validation error',\n        code: 'PARAMS_VALIDATION_SYSTEM_ERROR',\n      });\n    }\n  };\n}\n\n// Common validation schemas\nexport const CommonSchemas = {\n  // UUID parameter\n  uuid: z.object({\n    id: z.string().uuid('Invalid UUID format'),\n  }),\n  \n  // Pagination query\n  pagination: z.object({\n    page: z.coerce.number().min(1).default(1),\n    limit: z.coerce.number().min(1).max(100).default(20),\n    offset: z.coerce.number().min(0).optional(),\n  }),\n  \n  // Search query\n  search: z.object({\n    q: z.string().min(1).max(100).optional(),\n    query: z.string().min(1).max(100).optional(),\n  }),\n  \n  // Sorting\n  sort: z.object({\n    sortBy: z.string().min(1).max(50).optional(),\n    sortOrder: z.enum(['asc', 'desc']).default('desc'),\n  }),\n  \n  // Date range\n  dateRange: z.object({\n    startDate: z.coerce.date().optional(),\n    endDate: z.coerce.date().optional(),\n  }),\n};\n\n// Sanitization utilities\nexport class Sanitizer {\n  static sanitizeString(str: string, maxLength = 1000): string {\n    return str\n      .trim()\n      .slice(0, maxLength)\n      .replace(/[<>\"'&]/g, ''); // Basic XSS prevention\n  }\n  \n  static sanitizeHtml(html: string): string {\n    // In production, use a proper HTML sanitizer like DOMPurify\n    return html\n      .replace(/<script[^>]*>.*?<\\/script>/gi, '')\n      .replace(/<iframe[^>]*>.*?<\\/iframe>/gi, '')\n      .replace(/javascript:/gi, '')\n      .replace(/on\\w+\\s*=/gi, '');\n  }\n  \n  static sanitizeEmail(email: string): string {\n    return email.toLowerCase().trim();\n  }\n  \n  static sanitizeUsername(username: string): string {\n    return username\n      .toLowerCase()\n      .trim()\n      .replace(/[^a-z0-9_]/g, '');\n  }\n}\n\n// Input sanitization middleware\nexport function sanitizeInput(req: Request, res: Response, next: NextFunction) {\n  try {\n    // Sanitize body\n    if (req.body && typeof req.body === 'object') {\n      req.body = sanitizeObject(req.body);\n    }\n    \n    // Sanitize query\n    if (req.query && typeof req.query === 'object') {\n      req.query = sanitizeObject(req.query);\n    }\n    \n    next();\n  } catch (error) {\n    console.error('Sanitization error:', error);\n    next(); // Continue even if sanitization fails\n  }\n}\n\nfunction sanitizeObject(obj: any): any {\n  if (typeof obj === 'string') {\n    return Sanitizer.sanitizeString(obj);\n  }\n  \n  if (Array.isArray(obj)) {\n    return obj.map(sanitizeObject);\n  }\n  \n  if (obj && typeof obj === 'object') {\n    const sanitized: any = {};\n    for (const [key, value] of Object.entries(obj)) {\n      sanitized[key] = sanitizeObject(value);\n    }\n    return sanitized;\n  }\n  \n  return obj;\n}"