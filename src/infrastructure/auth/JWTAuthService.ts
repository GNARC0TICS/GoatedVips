import jwt from 'jsonwebtoken';\nimport crypto from 'crypto';\nimport { User } from '../../domain/entities/User';\nimport { ICacheService } from '../cache/ICacheService';\nimport { IUserRepository } from '../../domain/repositories/IUserRepository';\n\nexport interface TokenPayload {\n  userId: string;\n  email: string;\n  role: string;\n  sessionId: string;\n  iat?: number;\n  exp?: number;\n}\n\nexport interface AuthTokens {\n  accessToken: string;\n  refreshToken: string;\n  expiresIn: number;\n}\n\nexport interface SessionData {\n  userId: string;\n  email: string;\n  role: string;\n  ipAddress?: string;\n  userAgent?: string;\n  createdAt: Date;\n  lastAccessedAt: Date;\n}\n\nexport class JWTAuthService {\n  private readonly JWT_SECRET: string;\n  private readonly JWT_REFRESH_SECRET: string;\n  private readonly ACCESS_TOKEN_EXPIRY = '15m'; // 15 minutes\n  private readonly REFRESH_TOKEN_EXPIRY = '7d'; // 7 days\n  private readonly SESSION_EXPIRY = 7 * 24 * 60 * 60; // 7 days in seconds\n\n  constructor(\n    private cacheService: ICacheService,\n    private userRepository: IUserRepository,\n    jwtSecret?: string,\n    jwtRefreshSecret?: string\n  ) {\n    this.JWT_SECRET = jwtSecret || process.env.JWT_SECRET || this.generateSecureSecret();\n    this.JWT_REFRESH_SECRET = jwtRefreshSecret || process.env.JWT_REFRESH_SECRET || this.generateSecureSecret();\n    \n    if (!jwtSecret || !jwtRefreshSecret) {\n      console.warn('JWT secrets not provided, using generated secrets (not recommended for production)');\n    }\n  }\n\n  async generateTokens(user: User, ipAddress?: string, userAgent?: string): Promise<AuthTokens> {\n    const sessionId = this.generateSessionId();\n    \n    // Create session data\n    const sessionData: SessionData = {\n      userId: user.id,\n      email: user.email,\n      role: user.role,\n      ipAddress,\n      userAgent,\n      createdAt: new Date(),\n      lastAccessedAt: new Date(),\n    };\n    \n    // Store session in cache\n    await this.cacheService.set(\n      `session:${sessionId}`,\n      sessionData,\n      this.SESSION_EXPIRY\n    );\n    \n    // Create token payload\n    const payload: TokenPayload = {\n      userId: user.id,\n      email: user.email,\n      role: user.role,\n      sessionId,\n    };\n    \n    // Generate tokens\n    const accessToken = jwt.sign(payload, this.JWT_SECRET, {\n      expiresIn: this.ACCESS_TOKEN_EXPIRY,\n      issuer: 'goated-vips',\n      audience: 'goated-vips-app',\n    });\n    \n    const refreshToken = jwt.sign(\n      { userId: user.id, sessionId },\n      this.JWT_REFRESH_SECRET,\n      {\n        expiresIn: this.REFRESH_TOKEN_EXPIRY,\n        issuer: 'goated-vips',\n        audience: 'goated-vips-app',\n      }\n    );\n    \n    // Store refresh token\n    await this.cacheService.set(\n      `refresh:${sessionId}`,\n      refreshToken,\n      this.SESSION_EXPIRY\n    );\n    \n    return {\n      accessToken,\n      refreshToken,\n      expiresIn: 15 * 60, // 15 minutes in seconds\n    };\n  }\n\n  async verifyAccessToken(token: string): Promise<TokenPayload | null> {\n    try {\n      const payload = jwt.verify(token, this.JWT_SECRET, {\n        issuer: 'goated-vips',\n        audience: 'goated-vips-app',\n      }) as TokenPayload;\n      \n      // Verify session exists\n      const sessionExists = await this.cacheService.exists(`session:${payload.sessionId}`);\n      if (!sessionExists) {\n        return null;\n      }\n      \n      // Update last accessed time\n      await this.updateSessionAccess(payload.sessionId);\n      \n      return payload;\n    } catch (error) {\n      return null;\n    }\n  }\n\n  async refreshTokens(refreshToken: string): Promise<AuthTokens | null> {\n    try {\n      const payload = jwt.verify(refreshToken, this.JWT_REFRESH_SECRET, {\n        issuer: 'goated-vips',\n        audience: 'goated-vips-app',\n      }) as any;\n      \n      // Verify refresh token exists in cache\n      const storedToken = await this.cacheService.get(`refresh:${payload.sessionId}`);\n      if (storedToken !== refreshToken) {\n        return null;\n      }\n      \n      // Get session data\n      const sessionData = await this.cacheService.get<SessionData>(`session:${payload.sessionId}`);\n      if (!sessionData) {\n        return null;\n      }\n      \n      // Get user data\n      const user = await this.userRepository.findById(payload.userId);\n      if (!user || user.status !== 'active') {\n        return null;\n      }\n      \n      // Generate new tokens\n      return this.generateTokens(user, sessionData.ipAddress, sessionData.userAgent);\n    } catch (error) {\n      return null;\n    }\n  }\n\n  async revokeSession(sessionId: string): Promise<void> {\n    await Promise.all([\n      this.cacheService.delete(`session:${sessionId}`),\n      this.cacheService.delete(`refresh:${sessionId}`),\n    ]);\n  }\n\n  async revokeAllUserSessions(userId: string): Promise<void> {\n    // In a real Redis implementation, you'd use SCAN to find all sessions for a user\n    // For now, we'll mark the user as requiring re-authentication\n    await this.cacheService.set(`user:${userId}:revoked`, true, this.SESSION_EXPIRY);\n  }\n\n  async validateSession(sessionId: string): Promise<SessionData | null> {\n    // Check if user sessions are revoked\n    const sessionData = await this.cacheService.get<SessionData>(`session:${sessionId}`);\n    if (!sessionData) {\n      return null;\n    }\n    \n    const isRevoked = await this.cacheService.get(`user:${sessionData.userId}:revoked`);\n    if (isRevoked) {\n      await this.revokeSession(sessionId);\n      return null;\n    }\n    \n    return sessionData;\n  }\n\n  async getUserSessions(userId: string): Promise<SessionData[]> {\n    // In a production Redis setup, you'd implement a proper session store\n    // This is a simplified version\n    const sessionData = await this.cacheService.get<SessionData>(`session:${userId}`);\n    return sessionData ? [sessionData] : [];\n  }\n\n  private async updateSessionAccess(sessionId: string): Promise<void> {\n    const sessionData = await this.cacheService.get<SessionData>(`session:${sessionId}`);\n    if (sessionData) {\n      sessionData.lastAccessedAt = new Date();\n      await this.cacheService.set(`session:${sessionId}`, sessionData, this.SESSION_EXPIRY);\n    }\n  }\n\n  private generateSessionId(): string {\n    return crypto.randomBytes(32).toString('hex');\n  }\n\n  private generateSecureSecret(): string {\n    return crypto.randomBytes(64).toString('hex');\n  }\n\n  // Security utilities\n  async isTokenBlacklisted(token: string): Promise<boolean> {\n    return await this.cacheService.exists(`blacklist:${this.hashToken(token)}`);\n  }\n\n  async blacklistToken(token: string, expiresIn: number): Promise<void> {\n    const hashedToken = this.hashToken(token);\n    await this.cacheService.set(`blacklist:${hashedToken}`, true, expiresIn);\n  }\n\n  private hashToken(token: string): string {\n    return crypto.createHash('sha256').update(token).digest('hex');\n  }\n\n  // Admin functions\n  async getActiveSessionsCount(): Promise<number> {\n    // This would need to be implemented with proper Redis SCAN in production\n    return 0;\n  }\n\n  async cleanupExpiredSessions(): Promise<number> {\n    // Redis TTL handles this automatically, but this could be used for cleanup\n    return 0;\n  }\n}"