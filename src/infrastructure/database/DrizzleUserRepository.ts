import { drizzle } from 'drizzle-orm/neon-http';\nimport { eq, like, or, desc, asc, and, sql, count } from 'drizzle-orm';\nimport { neon } from '@neondatabase/serverless';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport { User, CreateUserInput, UpdateUserInput } from '../../domain/entities/User';\nimport { IUserRepository } from '../../domain/repositories/IUserRepository';\nimport { users, userSessions } from './schema';\n\nexport class DrizzleUserRepository implements IUserRepository {\n  private db;\n  \n  constructor(connectionString: string) {\n    const sql = neon(connectionString);\n    this.db = drizzle(sql);\n  }\n\n  async create(input: CreateUserInput): Promise<User> {\n    const id = uuidv4();\n    const now = new Date();\n    \n    const userData = {\n      id,\n      ...input,\n      createdAt: now,\n      updatedAt: now,\n    };\n    \n    const [user] = await this.db\n      .insert(users)\n      .values(userData)\n      .returning();\n      \n    return this.mapToEntity(user);\n  }\n\n  async findById(id: string): Promise<User | null> {\n    const [user] = await this.db\n      .select()\n      .from(users)\n      .where(eq(users.id, id))\n      .limit(1);\n      \n    return user ? this.mapToEntity(user) : null;\n  }\n\n  async findByEmail(email: string): Promise<User | null> {\n    const [user] = await this.db\n      .select()\n      .from(users)\n      .where(eq(users.email, email.toLowerCase()))\n      .limit(1);\n      \n    return user ? this.mapToEntity(user) : null;\n  }\n\n  async findByUsername(username: string): Promise<User | null> {\n    const [user] = await this.db\n      .select()\n      .from(users)\n      .where(eq(users.username, username))\n      .limit(1);\n      \n    return user ? this.mapToEntity(user) : null;\n  }\n\n  async update(id: string, input: UpdateUserInput): Promise<User | null> {\n    const updateData = {\n      ...input,\n      updatedAt: new Date(),\n    };\n    \n    const [user] = await this.db\n      .update(users)\n      .set(updateData)\n      .where(eq(users.id, id))\n      .returning();\n      \n    return user ? this.mapToEntity(user) : null;\n  }\n\n  async delete(id: string): Promise<boolean> {\n    const result = await this.db\n      .update(users)\n      .set({ \n        status: 'deleted',\n        updatedAt: new Date()\n      })\n      .where(eq(users.id, id));\n      \n    return result.rowCount > 0;\n  }\n\n  async findByGoatedId(goatedId: string): Promise<User | null> {\n    const [user] = await this.db\n      .select()\n      .from(users)\n      .where(eq(users.goatedId, goatedId))\n      .limit(1);\n      \n    return user ? this.mapToEntity(user) : null;\n  }\n\n  async linkGoatedAccount(userId: string, goatedId: string, goatedUsername: string): Promise<User | null> {\n    const [user] = await this.db\n      .update(users)\n      .set({\n        goatedId,\n        goatedUsername,\n        goatedLinked: true,\n        updatedAt: new Date(),\n      })\n      .where(eq(users.id, userId))\n      .returning();\n      \n    return user ? this.mapToEntity(user) : null;\n  }\n\n  async unlinkGoatedAccount(userId: string): Promise<User | null> {\n    const [user] = await this.db\n      .update(users)\n      .set({\n        goatedId: null,\n        goatedUsername: null,\n        goatedLinked: false,\n        goatedVerified: false,\n        updatedAt: new Date(),\n      })\n      .where(eq(users.id, userId))\n      .returning();\n      \n    return user ? this.mapToEntity(user) : null;\n  }\n\n  async search(query: string, limit = 20, offset = 0): Promise<{ users: User[]; total: number }> {\n    const searchPattern = `%${query.toLowerCase()}%`;\n    \n    // Get total count\n    const [{ count: totalCount }] = await this.db\n      .select({ count: count() })\n      .from(users)\n      .where(\n        and(\n          eq(users.status, 'active'),\n          or(\n            like(sql`LOWER(${users.username})`, searchPattern),\n            like(sql`LOWER(${users.displayName})`, searchPattern),\n            like(sql`LOWER(${users.goatedUsername})`, searchPattern),\n            eq(users.goatedId, query)\n          )\n        )\n      );\n    \n    // Get users\n    const userResults = await this.db\n      .select()\n      .from(users)\n      .where(\n        and(\n          eq(users.status, 'active'),\n          or(\n            like(sql`LOWER(${users.username})`, searchPattern),\n            like(sql`LOWER(${users.displayName})`, searchPattern),\n            like(sql`LOWER(${users.goatedUsername})`, searchPattern),\n            eq(users.goatedId, query)\n          )\n        )\n      )\n      .orderBy(desc(users.lastActiveAt))\n      .limit(limit)\n      .offset(offset);\n    \n    return {\n      users: userResults.map(user => this.mapToEntity(user)),\n      total: totalCount\n    };\n  }\n\n  async list(filters = {}, pagination = { limit: 20, offset: 0 }): Promise<{ users: User[]; total: number }> {\n    const conditions = [];\n    \n    if (filters.role) {\n      conditions.push(eq(users.role, filters.role));\n    }\n    if (filters.status) {\n      conditions.push(eq(users.status, filters.status));\n    }\n    if (filters.verified !== undefined) {\n      conditions.push(eq(users.emailVerified, filters.verified));\n    }\n    if (filters.goatedLinked !== undefined) {\n      conditions.push(eq(users.goatedLinked, filters.goatedLinked));\n    }\n    \n    const whereClause = conditions.length > 0 ? and(...conditions) : undefined;\n    \n    // Get total count\n    const [{ count: totalCount }] = await this.db\n      .select({ count: count() })\n      .from(users)\n      .where(whereClause);\n    \n    // Get users\n    const userResults = await this.db\n      .select()\n      .from(users)\n      .where(whereClause)\n      .orderBy(desc(users.createdAt))\n      .limit(pagination.limit)\n      .offset(pagination.offset);\n    \n    return {\n      users: userResults.map(user => this.mapToEntity(user)),\n      total: totalCount\n    };\n  }\n\n  async findByEmailVerificationToken(token: string): Promise<User | null> {\n    const [user] = await this.db\n      .select()\n      .from(users)\n      .where(eq(users.emailVerificationToken, token))\n      .limit(1);\n      \n    return user ? this.mapToEntity(user) : null;\n  }\n\n  async findByPasswordResetToken(token: string): Promise<User | null> {\n    const [user] = await this.db\n      .select()\n      .from(users)\n      .where(eq(users.passwordResetToken, token))\n      .limit(1);\n      \n    return user ? this.mapToEntity(user) : null;\n  }\n\n  async updateLastActivity(userId: string): Promise<void> {\n    await this.db\n      .update(users)\n      .set({ \n        lastActiveAt: new Date(),\n        updatedAt: new Date()\n      })\n      .where(eq(users.id, userId));\n  }\n\n  async incrementLoginCount(userId: string): Promise<void> {\n    await this.db\n      .update(users)\n      .set({ \n        loginCount: sql`${users.loginCount} + 1`,\n        lastLoginAt: new Date(),\n        updatedAt: new Date()\n      })\n      .where(eq(users.id, userId));\n  }\n\n  async getStats(): Promise<{\n    total: number;\n    verified: number;\n    goatedLinked: number;\n    activeToday: number;\n    activeThisWeek: number;\n  }> {\n    const today = new Date();\n    today.setHours(0, 0, 0, 0);\n    \n    const thisWeek = new Date();\n    thisWeek.setDate(thisWeek.getDate() - 7);\n    \n    const [stats] = await this.db\n      .select({\n        total: count(),\n        verified: count(sql`CASE WHEN ${users.emailVerified} = true THEN 1 END`),\n        goatedLinked: count(sql`CASE WHEN ${users.goatedLinked} = true THEN 1 END`),\n        activeToday: count(sql`CASE WHEN ${users.lastActiveAt} >= ${today} THEN 1 END`),\n        activeThisWeek: count(sql`CASE WHEN ${users.lastActiveAt} >= ${thisWeek} THEN 1 END`),\n      })\n      .from(users)\n      .where(eq(users.status, 'active'));\n      \n    return stats;\n  }\n\n  private mapToEntity(dbUser: any): User {\n    return {\n      id: dbUser.id,\n      username: dbUser.username,\n      email: dbUser.email,\n      passwordHash: dbUser.passwordHash,\n      role: dbUser.role,\n      status: dbUser.status,\n      displayName: dbUser.displayName,\n      bio: dbUser.bio,\n      avatar: dbUser.avatar,\n      profileColor: dbUser.profileColor,\n      goatedId: dbUser.goatedId,\n      goatedUsername: dbUser.goatedUsername,\n      goatedLinked: dbUser.goatedLinked,\n      goatedVerified: dbUser.goatedVerified,\n      privacy: dbUser.privacySettings || {},\n      preferences: dbUser.preferences || {},\n      emailVerified: dbUser.emailVerified,\n      emailVerificationToken: dbUser.emailVerificationToken,\n      twoFactorEnabled: dbUser.twoFactorEnabled,\n      twoFactorSecret: dbUser.twoFactorSecret,\n      passwordResetToken: dbUser.passwordResetToken,\n      passwordResetExpires: dbUser.passwordResetExpires,\n      lastPasswordChange: dbUser.lastPasswordChange,\n      lastLoginAt: dbUser.lastLoginAt,\n      lastActiveAt: dbUser.lastActiveAt,\n      loginCount: dbUser.loginCount,\n      createdAt: dbUser.createdAt,\n      updatedAt: dbUser.updatedAt,\n    };\n  }\n}"