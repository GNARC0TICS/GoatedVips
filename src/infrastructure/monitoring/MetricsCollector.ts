import { register, collectDefaultMetrics, Counter, Histogram, Gauge } from 'prom-client';\nimport { ICacheService } from '../cache/ICacheService';\n\n// Initialize default metrics collection\ncollectDefaultMetrics({ prefix: 'goated_vips_' });\n\nexport class MetricsCollector {\n  // HTTP metrics\n  private httpRequestDuration: Histogram<string>;\n  private httpRequestTotal: Counter<string>;\n  private httpRequestErrors: Counter<string>;\n  \n  // Authentication metrics\n  private authAttempts: Counter<string>;\n  private authSuccesses: Counter<string>;\n  private authFailures: Counter<string>;\n  private activeUsers: Gauge<string>;\n  private activeSessions: Gauge<string>;\n  \n  // Database metrics\n  private dbQueryDuration: Histogram<string>;\n  private dbQueryTotal: Counter<string>;\n  private dbQueryErrors: Counter<string>;\n  private dbConnectionPool: Gauge<string>;\n  \n  // Cache metrics\n  private cacheHits: Counter<string>;\n  private cacheMisses: Counter<string>;\n  private cacheOperationDuration: Histogram<string>;\n  \n  // Business metrics\n  private userRegistrations: Counter<string>;\n  private wagerTransactions: Counter<string>;\n  private raceParticipations: Counter<string>;\n  private apiErrors: Counter<string>;\n  \n  // System metrics\n  private memoryUsage: Gauge<string>;\n  private cpuUsage: Gauge<string>;\n  \n  constructor(private cacheService?: ICacheService) {\n    this.initializeMetrics();\n    this.startSystemMetricsCollection();\n  }\n\n  private initializeMetrics(): void {\n    // HTTP Metrics\n    this.httpRequestDuration = new Histogram({\n      name: 'goated_vips_http_request_duration_seconds',\n      help: 'Duration of HTTP requests in seconds',\n      labelNames: ['method', 'route', 'status_code'],\n      buckets: [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 5, 10],\n    });\n\n    this.httpRequestTotal = new Counter({\n      name: 'goated_vips_http_requests_total',\n      help: 'Total number of HTTP requests',\n      labelNames: ['method', 'route', 'status_code'],\n    });\n\n    this.httpRequestErrors = new Counter({\n      name: 'goated_vips_http_request_errors_total',\n      help: 'Total number of HTTP request errors',\n      labelNames: ['method', 'route', 'error_type'],\n    });\n\n    // Authentication Metrics\n    this.authAttempts = new Counter({\n      name: 'goated_vips_auth_attempts_total',\n      help: 'Total number of authentication attempts',\n      labelNames: ['type', 'result'],\n    });\n\n    this.authSuccesses = new Counter({\n      name: 'goated_vips_auth_successes_total',\n      help: 'Total number of successful authentications',\n      labelNames: ['type'],\n    });\n\n    this.authFailures = new Counter({\n      name: 'goated_vips_auth_failures_total',\n      help: 'Total number of failed authentications',\n      labelNames: ['type', 'reason'],\n    });\n\n    this.activeUsers = new Gauge({\n      name: 'goated_vips_active_users',\n      help: 'Number of currently active users',\n    });\n\n    this.activeSessions = new Gauge({\n      name: 'goated_vips_active_sessions',\n      help: 'Number of active user sessions',\n    });\n\n    // Database Metrics\n    this.dbQueryDuration = new Histogram({\n      name: 'goated_vips_db_query_duration_seconds',\n      help: 'Duration of database queries in seconds',\n      labelNames: ['operation', 'table'],\n      buckets: [0.001, 0.005, 0.01, 0.05, 0.1, 0.5, 1, 2, 5],\n    });\n\n    this.dbQueryTotal = new Counter({\n      name: 'goated_vips_db_queries_total',\n      help: 'Total number of database queries',\n      labelNames: ['operation', 'table'],\n    });\n\n    this.dbQueryErrors = new Counter({\n      name: 'goated_vips_db_query_errors_total',\n      help: 'Total number of database query errors',\n      labelNames: ['operation', 'table', 'error_type'],\n    });\n\n    this.dbConnectionPool = new Gauge({\n      name: 'goated_vips_db_connection_pool_size',\n      help: 'Number of database connections in pool',\n      labelNames: ['state'], // active, idle, total\n    });\n\n    // Cache Metrics\n    this.cacheHits = new Counter({\n      name: 'goated_vips_cache_hits_total',\n      help: 'Total number of cache hits',\n      labelNames: ['operation'],\n    });\n\n    this.cacheMisses = new Counter({\n      name: 'goated_vips_cache_misses_total',\n      help: 'Total number of cache misses',\n      labelNames: ['operation'],\n    });\n\n    this.cacheOperationDuration = new Histogram({\n      name: 'goated_vips_cache_operation_duration_seconds',\n      help: 'Duration of cache operations in seconds',\n      labelNames: ['operation'],\n      buckets: [0.0001, 0.0005, 0.001, 0.005, 0.01, 0.05, 0.1],\n    });\n\n    // Business Metrics\n    this.userRegistrations = new Counter({\n      name: 'goated_vips_user_registrations_total',\n      help: 'Total number of user registrations',\n      labelNames: ['source'],\n    });\n\n    this.wagerTransactions = new Counter({\n      name: 'goated_vips_wager_transactions_total',\n      help: 'Total number of wager transactions',\n      labelNames: ['type'],\n    });\n\n    this.raceParticipations = new Counter({\n      name: 'goated_vips_race_participations_total',\n      help: 'Total number of race participations',\n      labelNames: ['race_type'],\n    });\n\n    this.apiErrors = new Counter({\n      name: 'goated_vips_api_errors_total',\n      help: 'Total number of API errors',\n      labelNames: ['endpoint', 'error_code'],\n    });\n\n    // System Metrics\n    this.memoryUsage = new Gauge({\n      name: 'goated_vips_memory_usage_bytes',\n      help: 'Current memory usage in bytes',\n      labelNames: ['type'], // rss, heapUsed, heapTotal, external\n    });\n\n    this.cpuUsage = new Gauge({\n      name: 'goated_vips_cpu_usage_percent',\n      help: 'Current CPU usage percentage',\n    });\n  }\n\n  // HTTP Metrics Methods\n  recordHttpRequest(method: string, route: string, statusCode: number, duration: number): void {\n    this.httpRequestDuration.labels(method, route, statusCode.toString()).observe(duration);\n    this.httpRequestTotal.labels(method, route, statusCode.toString()).inc();\n  }\n\n  recordHttpError(method: string, route: string, errorType: string): void {\n    this.httpRequestErrors.labels(method, route, errorType).inc();\n  }\n\n  // Authentication Metrics Methods\n  recordAuthAttempt(type: string, result: 'success' | 'failure'): void {\n    this.authAttempts.labels(type, result).inc();\n    \n    if (result === 'success') {\n      this.authSuccesses.labels(type).inc();\n    }\n  }\n\n  recordAuthFailure(type: string, reason: string): void {\n    this.authFailures.labels(type, reason).inc();\n  }\n\n  setActiveUsers(count: number): void {\n    this.activeUsers.set(count);\n  }\n\n  setActiveSessions(count: number): void {\n    this.activeSessions.set(count);\n  }\n\n  // Database Metrics Methods\n  recordDbQuery(operation: string, table: string, duration: number): void {\n    this.dbQueryDuration.labels(operation, table).observe(duration);\n    this.dbQueryTotal.labels(operation, table).inc();\n  }\n\n  recordDbError(operation: string, table: string, errorType: string): void {\n    this.dbQueryErrors.labels(operation, table, errorType).inc();\n  }\n\n  setDbConnectionPool(active: number, idle: number, total: number): void {\n    this.dbConnectionPool.labels('active').set(active);\n    this.dbConnectionPool.labels('idle').set(idle);\n    this.dbConnectionPool.labels('total').set(total);\n  }\n\n  // Cache Metrics Methods\n  recordCacheHit(operation: string): void {\n    this.cacheHits.labels(operation).inc();\n  }\n\n  recordCacheMiss(operation: string): void {\n    this.cacheMisses.labels(operation).inc();\n  }\n\n  recordCacheOperation(operation: string, duration: number): void {\n    this.cacheOperationDuration.labels(operation).observe(duration);\n  }\n\n  // Business Metrics Methods\n  recordUserRegistration(source: string = 'web'): void {\n    this.userRegistrations.labels(source).inc();\n  }\n\n  recordWagerTransaction(type: string): void {\n    this.wagerTransactions.labels(type).inc();\n  }\n\n  recordRaceParticipation(raceType: string): void {\n    this.raceParticipations.labels(raceType).inc();\n  }\n\n  recordApiError(endpoint: string, errorCode: string): void {\n    this.apiErrors.labels(endpoint, errorCode).inc();\n  }\n\n  // System monitoring\n  private startSystemMetricsCollection(): void {\n    // Update memory metrics every 30 seconds\n    setInterval(() => {\n      const memUsage = process.memoryUsage();\n      this.memoryUsage.labels('rss').set(memUsage.rss);\n      this.memoryUsage.labels('heapUsed').set(memUsage.heapUsed);\n      this.memoryUsage.labels('heapTotal').set(memUsage.heapTotal);\n      this.memoryUsage.labels('external').set(memUsage.external);\n    }, 30000);\n\n    // Update CPU metrics every 10 seconds\n    let lastCpuUsage = process.cpuUsage();\n    setInterval(() => {\n      const currentCpuUsage = process.cpuUsage(lastCpuUsage);\n      const cpuPercent = (currentCpuUsage.user + currentCpuUsage.system) / 1000000 / 10 * 100; // 10 second interval\n      this.cpuUsage.set(cpuPercent);\n      lastCpuUsage = process.cpuUsage();\n    }, 10000);\n  }\n\n  // Get metrics for Prometheus\n  async getMetrics(): Promise<string> {\n    return register.metrics();\n  }\n\n  // Clear all metrics\n  clearMetrics(): void {\n    register.clear();\n  }\n\n  // Create timing decorator\n  createTimer(histogram: Histogram<string>, labels: Record<string, string>) {\n    const end = histogram.startTimer(labels);\n    return () => end();\n  }\n\n  // Middleware for automatic HTTP metrics collection\n  httpMetricsMiddleware() {\n    return (req: any, res: any, next: any) => {\n      const start = Date.now();\n      \n      res.on('finish', () => {\n        const duration = (Date.now() - start) / 1000;\n        const route = req.route?.path || req.path;\n        \n        this.recordHttpRequest(req.method, route, res.statusCode, duration);\n        \n        if (res.statusCode >= 400) {\n          this.recordHttpError(req.method, route, 'http_error');\n        }\n      });\n      \n      next();\n    };\n  }\n\n  // Database query wrapper with metrics\n  async wrapDbQuery<T>(\n    operation: string,\n    table: string,\n    queryFn: () => Promise<T>\n  ): Promise<T> {\n    const start = Date.now();\n    \n    try {\n      const result = await queryFn();\n      const duration = (Date.now() - start) / 1000;\n      this.recordDbQuery(operation, table, duration);\n      return result;\n    } catch (error: any) {\n      const duration = (Date.now() - start) / 1000;\n      this.recordDbQuery(operation, table, duration);\n      this.recordDbError(operation, table, error.name || 'unknown');\n      throw error;\n    }\n  }\n\n  // Cache operation wrapper with metrics\n  async wrapCacheOperation<T>(\n    operation: string,\n    cacheFn: () => Promise<T>,\n    isHit?: boolean\n  ): Promise<T> {\n    const start = Date.now();\n    \n    try {\n      const result = await cacheFn();\n      const duration = (Date.now() - start) / 1000;\n      \n      this.recordCacheOperation(operation, duration);\n      \n      if (isHit !== undefined) {\n        if (isHit) {\n          this.recordCacheHit(operation);\n        } else {\n          this.recordCacheMiss(operation);\n        }\n      }\n      \n      return result;\n    } catch (error) {\n      const duration = (Date.now() - start) / 1000;\n      this.recordCacheOperation(operation, duration);\n      throw error;\n    }\n  }\n}\n\n// Singleton instance\nlet metricsCollector: MetricsCollector;\n\nexport function getMetricsCollector(cacheService?: ICacheService): MetricsCollector {\n  if (!metricsCollector) {\n    metricsCollector = new MetricsCollector(cacheService);\n  }\n  return metricsCollector;\n}"