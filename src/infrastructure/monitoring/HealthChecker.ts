import { ICacheService } from '../cache/ICacheService';\nimport { IUserRepository } from '../../domain/repositories/IUserRepository';\n\n// Health status types\nexport type HealthStatus = 'healthy' | 'degraded' | 'unhealthy';\n\nexport interface HealthCheck {\n  name: string;\n  status: HealthStatus;\n  message?: string;\n  duration?: number;\n  metadata?: Record<string, any>;\n}\n\nexport interface OverallHealth {\n  status: HealthStatus;\n  timestamp: string;\n  uptime: number;\n  version: string;\n  environment: string;\n  checks: Record<string, HealthCheck>;\n  metadata?: Record<string, any>;\n}\n\n// Individual health check interface\nexport interface IHealthChecker {\n  name: string;\n  check(): Promise<HealthCheck>;\n}\n\n// Database health checker\nexport class DatabaseHealthChecker implements IHealthChecker {\n  name = 'database';\n  \n  constructor(private userRepository: IUserRepository) {}\n  \n  async check(): Promise<HealthCheck> {\n    const start = Date.now();\n    \n    try {\n      // Simple query to test database connectivity\n      await this.userRepository.getStats();\n      \n      const duration = Date.now() - start;\n      \n      return {\n        name: this.name,\n        status: duration < 1000 ? 'healthy' : 'degraded',\n        message: duration < 1000 ? 'Database responding normally' : 'Database responding slowly',\n        duration,\n        metadata: {\n          responseTime: `${duration}ms`,\n          threshold: '1000ms',\n        },\n      };\n    } catch (error: any) {\n      const duration = Date.now() - start;\n      \n      return {\n        name: this.name,\n        status: 'unhealthy',\n        message: `Database connection failed: ${error.message}`,\n        duration,\n        metadata: {\n          error: error.name,\n          code: error.code,\n        },\n      };\n    }\n  }\n}\n\n// Cache health checker\nexport class CacheHealthChecker implements IHealthChecker {\n  name = 'cache';\n  \n  constructor(private cacheService: ICacheService) {}\n  \n  async check(): Promise<HealthCheck> {\n    const start = Date.now();\n    \n    try {\n      // Test cache connectivity with ping\n      const result = await this.cacheService.ping();\n      const duration = Date.now() - start;\n      \n      if (result === 'PONG') {\n        return {\n          name: this.name,\n          status: duration < 100 ? 'healthy' : 'degraded',\n          message: duration < 100 ? 'Cache responding normally' : 'Cache responding slowly',\n          duration,\n          metadata: {\n            responseTime: `${duration}ms`,\n            threshold: '100ms',\n          },\n        };\n      } else {\n        return {\n          name: this.name,\n          status: 'unhealthy',\n          message: 'Cache ping returned unexpected result',\n          duration,\n          metadata: {\n            response: result,\n          },\n        };\n      }\n    } catch (error: any) {\n      const duration = Date.now() - start;\n      \n      return {\n        name: this.name,\n        status: 'unhealthy',\n        message: `Cache connection failed: ${error.message}`,\n        duration,\n        metadata: {\n          error: error.name,\n        },\n      };\n    }\n  }\n}\n\n// Memory health checker\nexport class MemoryHealthChecker implements IHealthChecker {\n  name = 'memory';\n  \n  constructor(\n    private memoryThresholds = {\n      warning: 0.8,  // 80%\n      critical: 0.9, // 90%\n    }\n  ) {}\n  \n  async check(): Promise<HealthCheck> {\n    const start = Date.now();\n    \n    try {\n      const memUsage = process.memoryUsage();\n      const totalMemory = memUsage.heapTotal;\n      const usedMemory = memUsage.heapUsed;\n      const usage = usedMemory / totalMemory;\n      \n      let status: HealthStatus = 'healthy';\n      let message = 'Memory usage is normal';\n      \n      if (usage >= this.memoryThresholds.critical) {\n        status = 'unhealthy';\n        message = 'Memory usage is critically high';\n      } else if (usage >= this.memoryThresholds.warning) {\n        status = 'degraded';\n        message = 'Memory usage is elevated';\n      }\n      \n      const duration = Date.now() - start;\n      \n      return {\n        name: this.name,\n        status,\n        message,\n        duration,\n        metadata: {\n          usagePercent: `${(usage * 100).toFixed(1)}%`,\n          heapUsed: `${Math.round(usedMemory / 1024 / 1024)}MB`,\n          heapTotal: `${Math.round(totalMemory / 1024 / 1024)}MB`,\n          rss: `${Math.round(memUsage.rss / 1024 / 1024)}MB`,\n          external: `${Math.round(memUsage.external / 1024 / 1024)}MB`,\n          thresholds: this.memoryThresholds,\n        },\n      };\n    } catch (error: any) {\n      const duration = Date.now() - start;\n      \n      return {\n        name: this.name,\n        status: 'unhealthy',\n        message: `Memory check failed: ${error.message}`,\n        duration,\n      };\n    }\n  }\n}\n\n// External API health checker\nexport class ExternalAPIHealthChecker implements IHealthChecker {\n  name = 'external_api';\n  \n  constructor(\n    private apiUrl: string,\n    private apiToken?: string,\n    private timeout = 5000\n  ) {}\n  \n  async check(): Promise<HealthCheck> {\n    const start = Date.now();\n    \n    try {\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), this.timeout);\n      \n      const headers: Record<string, string> = {\n        'User-Agent': 'GoatedVIPs-HealthChecker/1.0',\n      };\n      \n      if (this.apiToken) {\n        headers['Authorization'] = `Bearer ${this.apiToken}`;\n      }\n      \n      const response = await fetch(this.apiUrl, {\n        signal: controller.signal,\n        headers,\n      });\n      \n      clearTimeout(timeoutId);\n      const duration = Date.now() - start;\n      \n      if (response.ok) {\n        return {\n          name: this.name,\n          status: duration < 2000 ? 'healthy' : 'degraded',\n          message: duration < 2000 ? 'External API responding normally' : 'External API responding slowly',\n          duration,\n          metadata: {\n            url: this.apiUrl,\n            statusCode: response.status,\n            responseTime: `${duration}ms`,\n            threshold: '2000ms',\n          },\n        };\n      } else {\n        return {\n          name: this.name,\n          status: 'unhealthy',\n          message: `External API returned error status: ${response.status}`,\n          duration,\n          metadata: {\n            url: this.apiUrl,\n            statusCode: response.status,\n            statusText: response.statusText,\n          },\n        };\n      }\n    } catch (error: any) {\n      const duration = Date.now() - start;\n      \n      return {\n        name: this.name,\n        status: 'unhealthy',\n        message: `External API check failed: ${error.message}`,\n        duration,\n        metadata: {\n          url: this.apiUrl,\n          error: error.name,\n          timeout: this.timeout,\n        },\n      };\n    }\n  }\n}\n\n// Disk space health checker\nexport class DiskSpaceHealthChecker implements IHealthChecker {\n  name = 'disk_space';\n  \n  constructor(\n    private thresholds = {\n      warning: 0.8,  // 80%\n      critical: 0.9, // 90%\n    }\n  ) {}\n  \n  async check(): Promise<HealthCheck> {\n    const start = Date.now();\n    \n    try {\n      const fs = await import('fs/promises');\n      const stats = await fs.statfs('.');\n      \n      const total = stats.blocks * stats.bsize;\n      const free = stats.bavail * stats.bsize;\n      const used = total - free;\n      const usage = used / total;\n      \n      let status: HealthStatus = 'healthy';\n      let message = 'Disk space usage is normal';\n      \n      if (usage >= this.thresholds.critical) {\n        status = 'unhealthy';\n        message = 'Disk space usage is critically high';\n      } else if (usage >= this.thresholds.warning) {\n        status = 'degraded';\n        message = 'Disk space usage is elevated';\n      }\n      \n      const duration = Date.now() - start;\n      \n      return {\n        name: this.name,\n        status,\n        message,\n        duration,\n        metadata: {\n          usagePercent: `${(usage * 100).toFixed(1)}%`,\n          totalGB: `${(total / 1024 / 1024 / 1024).toFixed(1)}GB`,\n          usedGB: `${(used / 1024 / 1024 / 1024).toFixed(1)}GB`,\n          freeGB: `${(free / 1024 / 1024 / 1024).toFixed(1)}GB`,\n          thresholds: this.thresholds,\n        },\n      };\n    } catch (error: any) {\n      const duration = Date.now() - start;\n      \n      return {\n        name: this.name,\n        status: 'unhealthy',\n        message: `Disk space check failed: ${error.message}`,\n        duration,\n      };\n    }\n  }\n}\n\n// Main health checker orchestrator\nexport class HealthChecker {\n  private checkers: Map<string, IHealthChecker> = new Map();\n  private startTime = Date.now();\n  \n  constructor() {}\n  \n  // Register a health checker\n  register(checker: IHealthChecker): void {\n    this.checkers.set(checker.name, checker);\n  }\n  \n  // Unregister a health checker\n  unregister(name: string): void {\n    this.checkers.delete(name);\n  }\n  \n  // Run all health checks\n  async checkHealth(includeChecks: string[] = []): Promise<OverallHealth> {\n    const checksToRun = includeChecks.length > 0 \n      ? Array.from(this.checkers.entries()).filter(([name]) => includeChecks.includes(name))\n      : Array.from(this.checkers.entries());\n    \n    // Run all checks in parallel\n    const checkPromises = checksToRun.map(async ([name, checker]) => {\n      try {\n        const result = await checker.check();\n        return [name, result] as [string, HealthCheck];\n      } catch (error: any) {\n        return [name, {\n          name,\n          status: 'unhealthy' as HealthStatus,\n          message: `Health check failed: ${error.message}`,\n          metadata: { error: error.name },\n        }] as [string, HealthCheck];\n      }\n    });\n    \n    const checkResults = await Promise.all(checkPromises);\n    const checks = Object.fromEntries(checkResults);\n    \n    // Determine overall health status\n    const statuses = Object.values(checks).map(check => check.status);\n    let overallStatus: HealthStatus = 'healthy';\n    \n    if (statuses.includes('unhealthy')) {\n      overallStatus = 'unhealthy';\n    } else if (statuses.includes('degraded')) {\n      overallStatus = 'degraded';\n    }\n    \n    return {\n      status: overallStatus,\n      timestamp: new Date().toISOString(),\n      uptime: Date.now() - this.startTime,\n      version: process.env.npm_package_version || '1.0.0',\n      environment: process.env.NODE_ENV || 'development',\n      checks,\n      metadata: {\n        totalChecks: Object.keys(checks).length,\n        healthyChecks: statuses.filter(s => s === 'healthy').length,\n        degradedChecks: statuses.filter(s => s === 'degraded').length,\n        unhealthyChecks: statuses.filter(s => s === 'unhealthy').length,\n      },\n    };\n  }\n  \n  // Get a specific health check\n  async checkSpecific(name: string): Promise<HealthCheck | null> {\n    const checker = this.checkers.get(name);\n    if (!checker) {\n      return null;\n    }\n    \n    return await checker.check();\n  }\n  \n  // Get list of available checks\n  getAvailableChecks(): string[] {\n    return Array.from(this.checkers.keys());\n  }\n  \n  // Express middleware for health endpoint\n  middleware() {\n    return async (req: any, res: any) => {\n      try {\n        const includeChecks = req.query.checks \n          ? req.query.checks.split(',').map((s: string) => s.trim())\n          : [];\n        \n        const health = await this.checkHealth(includeChecks);\n        \n        const statusCode = health.status === 'healthy' ? 200 \n          : health.status === 'degraded' ? 200 \n          : 503;\n        \n        res.status(statusCode).json(health);\n      } catch (error: any) {\n        res.status(500).json({\n          status: 'unhealthy',\n          timestamp: new Date().toISOString(),\n          error: 'Health check system failure',\n          message: error.message,\n        });\n      }\n    };\n  }\n}\n\n// Factory function to create a configured health checker\nexport function createHealthChecker(config: {\n  userRepository?: IUserRepository;\n  cacheService?: ICacheService;\n  externalAPIUrl?: string;\n  externalAPIToken?: string;\n}): HealthChecker {\n  const healthChecker = new HealthChecker();\n  \n  // Register database health checker\n  if (config.userRepository) {\n    healthChecker.register(new DatabaseHealthChecker(config.userRepository));\n  }\n  \n  // Register cache health checker\n  if (config.cacheService) {\n    healthChecker.register(new CacheHealthChecker(config.cacheService));\n  }\n  \n  // Register memory health checker\n  healthChecker.register(new MemoryHealthChecker());\n  \n  // Register disk space health checker\n  healthChecker.register(new DiskSpaceHealthChecker());\n  \n  // Register external API health checker\n  if (config.externalAPIUrl) {\n    healthChecker.register(new ExternalAPIHealthChecker(\n      config.externalAPIUrl,\n      config.externalAPIToken\n    ));\n  }\n  \n  return healthChecker;\n}"